# 08 - CSS EXTRACTION

**Document:** CSS Extraction via Static Analysis
**Version:** 6.0.0
**Status:** Final

---

## OVERVIEW

ZUI's CSS extraction system analyzes Zig code at compile time to extract all generated CSS classes, producing an optimized and deduplicated CSS file.

---

## ARCHITECTURE

```
┌────────────────────────────────────────────────┐
│          BUILD PROCESS                          │
├────────────────────────────────────────────────┤
│                                                │
│  1. Parse Zig files                            │
│     └─> Find all styles.create() calls        │
│                                                │
│  2. Extract style definitions                  │
│     └─> Build style map                        │
│                                                │
│  3. Generate atomic CSS                        │
│     └─> Deduplicate classes                    │
│                                                │
│  4. Write output                               │
│     └─> styles.css + source map                │
│                                                │
└────────────────────────────────────────────────┘
```

---

## STATIC ANALYZER

```zig
// build/css_extractor.zig
const std = @import("std");

pub const CssExtractor = struct {
    allocator: std.mem.Allocator,
    styles: std.StringHashMap(StyleInfo),
    atomic_classes: std.StringHashMap([]const u8),

    const StyleInfo = struct {
        properties: std.StringHashMap([]const u8),
        source_file: []const u8,
        line: u32,
    };

    pub fn init(allocator: std.mem.Allocator) CssExtractor {
        return .{
            .allocator = allocator,
            .styles = std.StringHashMap(StyleInfo).init(allocator),
            .atomic_classes = std.StringHashMap([]const u8).init(allocator),
        };
    }

    pub fn deinit(self: *CssExtractor) void {
        self.styles.deinit();
        self.atomic_classes.deinit();
    }

    /// Extract styles from a Zig source file
    pub fn extractFromFile(self: *CssExtractor, file_path: []const u8) !void {
        const source = try std.fs.cwd().readFileAlloc(
            self.allocator,
            file_path,
            10 * 1024 * 1024, // 10MB max
        );
        defer self.allocator.free(source);

        try self.extractFromSource(source, file_path);
    }

    /// Extract styles from source code
    pub fn extractFromSource(
        self: *CssExtractor,
        source: []const u8,
        file_path: []const u8,
    ) !void {
        var line: u32 = 1;
        var i: usize = 0;

        while (i < source.len) {
            // Find styles.create( calls
            if (std.mem.startsWith(u8, source[i..], "styles.create(")) {
                i += "styles.create(".len;

                // Extract the style definition
                const style_def = try self.extractStyleDefinition(source[i..]);

                // Parse and store
                try self.parseStyleDefinition(style_def, file_path, line);
            }

            // Track line numbers
            if (source[i] == '\n') {
                line += 1;
            }

            i += 1;
        }
    }

    /// Parse style definition into properties
    fn parseStyleDefinition(
        self: *CssExtractor,
        def: []const u8,
        file_path: []const u8,
        line: u32,
    ) !void {
        var properties = std.StringHashMap([]const u8).init(self.allocator);

        // Parse .{ .property = value, ... } syntax
        // [implementation details...]

        // Generate atomic classes
        var prop_iter = properties.iterator();
        while (prop_iter.next()) |entry| {
            const class_name = try self.generateAtomicClass(
                entry.key_ptr.*,
                entry.value_ptr.*,
            );

            const css_rule = try self.generateCssRule(
                entry.key_ptr.*,
                entry.value_ptr.*,
            );

            try self.atomic_classes.put(class_name, css_rule);
        }
    }

    /// Write extracted CSS to file
    pub fn writeCss(self: *CssExtractor, output_path: []const u8) !void {
        var file = try std.fs.cwd().createFile(output_path, .{});
        defer file.close();

        var writer = file.writer();

        // Write header
        try writer.writeAll("/* Generated by ZUI CSS Extractor */\n\n");

        // Write atomic classes
        var iter = self.atomic_classes.iterator();
        while (iter.next()) |entry| {
            try writer.print("{s}\n", .{entry.value_ptr.*});
        }
    }
};
```

---

## BUILD INTEGRATION

```zig
// build.zig
pub fn build(b: *std.Build) void {
    // CSS extraction step
    const css_extract = b.addSystemCommand(&.{"zig"});
    css_extract.addArgs(&.{ "run", "build/extract_css.zig" });
    css_extract.addArg("--");
    css_extract.addFileSourceArg(.{ .path = "src" });
    css_extract.addArg("www/styles.css");
}
```

---

## OUTPUT

### Source Code

```zig
pub fn view(model: *const Model, ctx: *AppContext) Element(Msg) {
    return h.div(ctx, .{
        .style = styles.create(.{
            .display = .flex,
            .padding = .{ .rem = 2 },
        }),
    }, &.{});
}
```

### Generated CSS

```css
/* Generated by ZUI CSS Extractor */

.zui-display-3a4f { display: flex; }
.zui-padding-4c8a { padding: 2rem; }
```

---

## CONCLUSION

Build-time CSS extraction eliminates runtime overhead and produces optimal CSS.

**Links:**
- [← Previous: CSS Builder](07-css-builder.md)
- [→ Next: CSS Theme](09-css-theme.md)
- [↑ Back to index](../README.md)
